{"version":3,"sources":["parser/PossibleGrammars.ts","parser/Parser.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["constructParseFunction","inRegex","outRegex","dateElement","regexp","RegExp","regexp2","test","exec","PossibleGrammars","grammarName","possibleElements","sectionName","formatSpecifier","regexFunc","type","possibleSplits","splitName","splitOn","splitStringArray","matchElement","element","possibleMatches","Array","possibleSection","push","validMatch","possibleMatch0","possibleMatch1","possibleMatch2","parseDateString","dateString","languageChoice","possibleSplit","split","finalSplit","find","obj","length","undefined","dateElements","grammarChoice","grammar","Error","findGrammar","elementMatches","some","ele","possibleStringFormats","App","React","useState","parsedOptions","setParsedOptions","currentLanguage","setCurrentLangugae","className","style","width","Box","sx","display","justifyContent","alignItems","margin","textAlign","minHeight","id","alignContent","TextField","onChange","event","target","value","label","variant","List","dense","map","option","ListItem","secondaryAction","IconButton","edge","ListItemAvatar","Avatar","ListItemText","primary","secondary","FormControl","minWidth","InputLabel","Select","labelId","MenuItem","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.fc9dd9bb.chunk.js","sourcesContent":["import { Grammar } from \"./Grammer\"\n\nfunction constructParseFunction(inRegex: string | RegExp, outRegex: string | RegExp | null = null): Function{\n    if(outRegex){\n        return (dateElement: string): RegExpExecArray | null => {\n            var regexp = new RegExp(inRegex),\n                regexp2 = new RegExp(outRegex);\n\n            if(regexp.test(dateElement) && !regexp2.test(dateElement)){\n                return regexp.exec(dateElement);\n            }\n            return null;\n        };\n    }\n\n    return (dateElement: string): RegExpExecArray | null => {\n        var regexp = new RegExp(inRegex);\n\n        if(regexp.test(dateElement)){\n            return regexp.exec(dateElement);\n        }\n        return null;\n    };\n}\n\nexport const PossibleGrammars:Array<Grammar> \n= [ {\n        grammarName: \"C#\",\n        possibleElements: [\n            {\n                sectionName: \"day_of_month\",\n                formatSpecifier: \"d\",\n                regexFunc: constructParseFunction('^([1-3][0-9]|[1-9])$', '^(3[2-9])$'),\n                type: \"day\"\n            },\n            {\n                sectionName: \"day_of_month_two_digits\",\n                formatSpecifier: \"dd\",\n                regexFunc: constructParseFunction('^([0-3][0-9])$', '^([3-9][2-9])$'),\n                type: \"day\"\n            },\n            {\n                sectionName: \"day_abvr\",\n                formatSpecifier: \"ddd\",\n                regexFunc: constructParseFunction(/^(Sun|Mon|Tue|Wed|Thu|Fri|Sat)$/i),\n                type: \"day\"\n            },\n            {\n                sectionName: \"day_full\",\n                formatSpecifier: \"dddd\",\n                regexFunc: constructParseFunction(/^(Sunday|Monday|Tuesday|Wednesday|Thusday|Friday|Saturday)$/i),\n                type: \"day\"\n            },\n            {\n                sectionName: \"month_one_or_two_digits\",\n                formatSpecifier: \"M\",\n                regexFunc: constructParseFunction('^((1|)[0-9])$', '^[1][3-9]$'),\n                type: \"month\"\n            },\n            {\n                sectionName: \"month_two_digits\",\n                formatSpecifier: \"MM\",\n                regexFunc: constructParseFunction('^[0-2][1-9]$', '^[1-9][3-9]$'),\n                type: \"month\"\n            },\n            {\n                sectionName: \"month_abvr\",\n                formatSpecifier: \"MMM\",\n                regexFunc: constructParseFunction(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i),\n                type: \"month\"\n            },\n            {\n                sectionName: \"month_full\",\n                formatSpecifier: \"MMMM\",\n                regexFunc: constructParseFunction(/^(January|February|March|April|May|June|July|August|September|Octover|November|Deccember)$/i),\n                type: \"month\"\n            },\n            {\n                sectionName: \"year_one_or_two_digits\",\n                formatSpecifier: \"y\",\n                regexFunc: constructParseFunction('^(0?[1-9]|[1-9][0-9])$'),\n                type: \"year\"\n            },\n            {\n                sectionName: \"year_two_digits\",\n                formatSpecifier: \"yy\",\n                regexFunc: constructParseFunction('^[0-9][0-9]$'),\n                type: \"year\"\n            },\n            {\n                sectionName: \"year_four_digits\",\n                formatSpecifier: \"yyyy\",\n                regexFunc: constructParseFunction('^[0-9]{4}$'),\n                type: \"year\"\n            }\n        ]\n\n    }\n    \n]","import { PossibleElement } from \"./PossibleElement\";\nimport { Grammar } from \"./Grammer\";\nimport { string } from \"yargs\";\nimport { Split } from \"./Split\";\nimport { MatchElement } from \"./MatchElement\";\nimport { PossibleGrammars } from \"./PossibleGrammars\";\n\n\nconst possibleSplits: Split[]\n    = [\n        {\n            splitName: \"dash\",\n            splitOn: \"-\",\n            splitStringArray: null\n        },\n        {\n            splitName: \"foward_slash\",\n            splitOn: \"/\",\n            splitStringArray: null\n        },\n        {\n            splitName: \"space\",\n            splitOn: \" \",\n            splitStringArray: null\n        }\n    ]\n\n// Returns an array of possible character codes the given element string COULD represent\nfunction matchElement(element: string, possibleElements: Array<PossibleElement>): Array<PossibleElement> {\n    var possibleMatches = new Array<PossibleElement>();\n\n    for (let possibleSection of possibleElements) {\n        var result = possibleSection.regexFunc(element)\n\n        if (result) {\n            possibleMatches.push(possibleSection);\n        }\n    }\n\n    return possibleMatches;\n}\n\nfunction findGrammar(grammarChoice: string): Array<PossibleElement> {\n    for (let grammar of PossibleGrammars) {\n        if (grammar.grammarName === grammarChoice) {\n            return grammar.possibleElements\n        }\n    }\n    throw new Error(\"Can't find the appropiate grammer for that choice!\");\n}\n\n// Checks that there isn't a duplicate type - for example 'dd-dd-yyyy' is invalid\nfunction validMatch(matchElement: MatchElement): boolean {\n    return matchElement.possibleMatch0.type !== matchElement.possibleMatch1.type &&\n        matchElement.possibleMatch0.type !== matchElement.possibleMatch2.type &&\n        matchElement.possibleMatch1.type !== matchElement.possibleMatch2.type;\n}\n\nexport function parseDateString(dateString: string, languageChoice: string): string[] {\n    // Step 1: split the string into groups\n    for (let possibleSplit of possibleSplits) {\n        possibleSplit.splitStringArray = dateString.split(possibleSplit.splitOn);\n    }\n\n    let finalSplit = possibleSplits.find((obj) => obj.splitStringArray?.length === 3);\n\n    if (finalSplit === undefined) return new Array<string>();\n\n    let dateElements = finalSplit?.splitStringArray;\n\n    // Needs to be date nicly split into three sections\n    if (dateElements?.length !== 3) return new Array<string>();\n\n    let possibleElements = findGrammar(languageChoice)\n\n    let elementMatches = Array<{\n        element: string,\n        possibleMatches: PossibleElement[]\n    }>();\n\n    // Step 2: try to match the elements of the split into their closest match\n    for (let element of dateElements!) {\n        let possibleMatches = matchElement(element, possibleElements);\n\n        elementMatches.push({ element, possibleMatches })\n    }\n\n    // There needs to be at least one match per each date element\n    if (elementMatches.some((ele) => ele.possibleMatches.length < 1)) new Array<string>();\n\n    var possibleStringFormats = new Array<string>();\n\n    // Step 3: Iterate through all possible match configurations\n    for (let possibleMatch0 of elementMatches[0].possibleMatches) {\n        for (let possibleMatch1 of elementMatches[1].possibleMatches) {\n            for (let possibleMatch2 of elementMatches[2].possibleMatches) {\n                // Only if the match configuration is valid, we can append the string\n                if (validMatch({ possibleMatch0, possibleMatch1, possibleMatch2 })) {\n                    possibleStringFormats.push(`${possibleMatch0.formatSpecifier}${finalSplit.splitOn}${possibleMatch1.formatSpecifier}${finalSplit.splitOn}${possibleMatch2.formatSpecifier}`)\n                }\n            }\n        }\n    }\n\n    return possibleStringFormats;\n}\n\n\n/*\n    Testing Suite\n*/\nconst testSamples = [\n    {\n        data: \"2021-2-1\",\n        isValid: true,\n        result: [\"yyyy-M-d\", \"yyyy-d-M\"]\n\n    },\n    {\n        data: \"2021-02-01\",\n        isValid: true,\n        result: [\"yyyy-MM-dd\", \"yyyy-dd-MM\"]\n\n    },\n    {\n        data: \"feb 28 0006\",\n        isValid: true,\n        result: [\"MMM dd yyyy\", \"MMM d yyyy\"]\n\n    },\n    {\n        data: \"6/12/2021\",\n        isValid: true,\n        result: [\"M/d/2021\", \"M/dd/2021\", \"M/d/yyyy\", \"M/dd/yyyy\"]\n\n    },\n    {\n        data: \"06-06-2021\",\n        isValid: true,\n        result: [\"dd-MM-yyyy\", \"MM-dd-yyyy\"]\n\n    },\n    {\n        data: \"06/12/98\",\n        isValid: true,\n        result: [\"dd/M/y\", \"dd/M/yy\", \"dd/MM/y\", \"dd/MM/yy\", \"MM/d/y\", \"MM/d/yy\", \"MM/dd/y\", \"MM/dd/yy\"]\n\n    },\n    {\n        data: \"6 01 1998\",\n        isValid: true,\n        result: [\"M dd yyyy\", \"d MM yyyy\"]\n\n    },\n    {\n        data: \"march 1 98\",\n        isValid: true,\n        result: [\"MMMM d yy\", \"MMMM d y\"]\n\n    },\n    {\n        data: \"06 sunday 1998\",\n        isValid: true,\n        result: [\"dd dddd yyyy\"]\n\n    },\n    {\n        data: \"31 Fri 2\",\n        isValid: true,\n        result: [\"d mmm y\", \"dd mmm y\"]\n\n    },\n    {\n        data: \"this is a test\",\n        isValid: false,\n        result: []\n\n    }\n]\n\n\n// console.log(parseDateString('6/12/2021'));\n// for (let sample of testSamples) {\n//     let result = parseDateString(sample.data, \"C#\");\n\n//     if (result.length === sample.result.length &&\n//         result.every((str) => result?.includes(str))) {\n//         console.log(`Pass for ${sample.data}`);\n//     }\n//     else {\n//         console.log(`Fail for ${sample.data}`);\n//         console.log(`${result} does not match ${sample.result}`);\n//     }\n// }","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport { parseDateString } from './parser/Parser';\nimport { Avatar, FormControl, IconButton, InputLabel, List, ListItem, ListItemAvatar, ListItemButton, ListItemText, MenuItem, Select, TextField } from '@mui/material';\nimport { Box } from '@mui/system';\n\nconst App: React.FC = () => {\n  const [parsedOptions, setParsedOptions] = React.useState(parseDateString(\"2021-12-01\", \"C#\"));\n  const [currentLanguage, setCurrentLangugae] = React.useState(\"C#\");\n\n  const onUserInput = (event: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>): void => {\n    setParsedOptions(parseDateString(event.target.value, \"C#\"));\n  }\n\n  const onLanguageSelect = (event: { target: { value: React.SetStateAction<string>; }; }): void => {\n    setCurrentLangugae(event.target.value);\n  }\n\n  return (\n    <div className=\"App\">\n      <div style={{ width: '100%' }}>\n        <Box\n          sx={{\n            display: 'flex',\n            justifyContent: 'center',\n            alignItems: 'center',\n            margin: 'auto',\n            textAlign: 'center',\n            minHeight: '100vh',\n          }}\n        >\n          <Box\n            sx={{\n              display: 'flex',\n              justifyContent: 'center',\n              margin: 'auto',\n            }}\n          >\n            <Box\n              id=\"data-box\"\n              sx={{\n                display: 'grid',\n                justifyContent: 'center',\n                alignContent: 'flex-start',\n                margin: '10px',\n              }}\n            >\n              <Box\n                sx={{\n                }}\n              >\n                <TextField onChange={onUserInput} id=\"outlined-basic\" label={currentLanguage} variant=\"filled\" />\n              </Box>\n              <Box\n                sx={{\n                }}\n              >\n                <List dense={true}>\n                  {\n                    parsedOptions.map((option: string) => {\n                      return (<ListItem\n                        secondaryAction={\n                          <IconButton edge=\"end\" aria-label=\"delete\">\n                          </IconButton>\n                        }\n                      >\n                        <ListItemAvatar>\n                          <Avatar>\n                          </Avatar>\n                        </ListItemAvatar>\n                        <ListItemText\n                          primary={option}\n                          secondary={true ? 'Secondary text' : null}\n                        />\n                      </ListItem>);\n                    })\n                  }\n                </List>\n              </Box>\n            </Box>\n            <Box\n              id=\"select-box\"\n              sx={{\n                margin: '10px',\n              }}\n            >\n              <FormControl variant=\"filled\" sx={{ minWidth: 120 }}>\n                <InputLabel id=\"language-input-label\">Language</InputLabel>\n                <Select\n                  labelId=\"select\"\n                  id=\"select\"\n                  value={currentLanguage}\n                  onChange={onLanguageSelect}\n                >\n                  <MenuItem value={\"C#\"}>C#</MenuItem>\n                  <MenuItem value={\"Python\"}>Python</MenuItem>\n                </Select>\n              </FormControl>\n            </Box>\n          </Box>\n\n        </Box>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}